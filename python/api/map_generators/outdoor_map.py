import numpy as np
import numpy.random as rnd
from typing import Any
from collections import defaultdict

from scipy.sparse import coo

#######################################################################
#########   PERLIN NOISE GENERATOR FROM GITHUB USER PVIGIER   #########
#########       https://github.com/pvigier/perlin-numpy       #########
#########             PUBLISHED UNDER MIT LICENSE             #########
#######################################################################

def interpolant(t):
    return t*t*t*(t*(t*6 - 15) + 10)

# I added the seed and changed the np.random call to rnd as imported
def generate_perlin_noise_2d(
        shape, res, seed = None, tileable=(False, False), interpolant=interpolant
):
    """Generate a 2D numpy array of perlin noise.
    Args:
        shape: The shape of the generated array (tuple of two ints).
            This must be a multple of res.
        res: The number of periods of noise to generate along each
            axis (tuple of two ints). Note shape must be a multiple of
            res.
        seed: Seed for the pseudorandom number generator
        tileable: If the noise should be tileable along each axis
            (tuple of two bools). Defaults to (False, False).
        interpolant: The interpolation function, defaults to
            t*t*t*(t*(t*6 - 15) + 10).
    Returns:
        A numpy array of shape shape with the generated noise.
    Raises:
        ValueError: If shape is not a multiple of res.
    """
    delta = (res[0] / shape[0], res[1] / shape[1])
    d = (shape[0] // res[0], shape[1] // res[1])
    grid = np.mgrid[0:res[0]:delta[0], 0:res[1]:delta[1]]\
             .transpose(1, 2, 0) % 1
    # Random seed
    if seed:
        rnd.seed(seed)
    # Gradients
    angles = 2*np.pi*rnd.rand(res[0]+1, res[1]+1)
    gradients = np.dstack((np.cos(angles), np.sin(angles)))
    if tileable[0]:
        gradients[-1,:] = gradients[0,:]
    if tileable[1]:
        gradients[:,-1] = gradients[:,0]
    gradients = gradients.repeat(d[0], 0).repeat(d[1], 1)
    g00 = gradients[    :-d[0],    :-d[1]]
    g10 = gradients[d[0]:     ,    :-d[1]]
    g01 = gradients[    :-d[0],d[1]:     ]
    g11 = gradients[d[0]:     ,d[1]:     ]
    # Ramps
    n00 = np.sum(np.dstack((grid[:,:,0]  , grid[:,:,1]  )) * g00, 2)
    n10 = np.sum(np.dstack((grid[:,:,0]-1, grid[:,:,1]  )) * g10, 2)
    n01 = np.sum(np.dstack((grid[:,:,0]  , grid[:,:,1]-1)) * g01, 2)
    n11 = np.sum(np.dstack((grid[:,:,0]-1, grid[:,:,1]-1)) * g11, 2)
    # Interpolation
    t = interpolant(grid)
    n0 = n00*(1-t[:,:,0]) + t[:,:,0]*n10
    n1 = n01*(1-t[:,:,0]) + t[:,:,0]*n11
    return np.sqrt(2)*((1-t[:,:,1])*n0 + t[:,:,1]*n1)

#######################################################################
#######################################################################

class OutdoorMap:

    RANGE = [0, 4]
    
    def __init__(self, width : int, height : int, seed : Any):
        self.MAP_WIDTH = width
        self.MAP_HEIGHT = height
        self.PERLIN_RES = (height//10, width//10)
        self.spawn_points = []
        self.treasure_locations = []
        self.seed = seed
        self._initialize_grid()
    
    def _initialize_grid(self):
        self.grid = generate_perlin_noise_2d(
            shape = (self.MAP_HEIGHT, self.MAP_WIDTH),
            res = self.PERLIN_RES,
            seed = self.seed,
            tileable = (True, True)
        )
    
    def create_map(self):
        # Interpolate the values generated by
        # Perlin noise to integers in range `RANGE`
        try: 
            self.grid = np.interp(
                self.grid,
                [self.grid.min(), self.grid.max()], 
                self.RANGE
            ).astype(int)

            self.__add_border()
            self.__add_spawn_points_and_treasure_locations()
        except Exception:
            self.seed = self.seed * 123
            self._initialize_grid()
            self.create_map()

    def __add_border(self):
        for y, row in enumerate(self.grid):
            for x, _ in enumerate(row):
                # I'd like the boundary of the map to stay as walls :D
                if x == 0 or x == self.MAP_WIDTH-1 or y == 0 or y == self.MAP_HEIGHT -1:
                    self.grid[y][x] = 99

    def __add_spawn_points_and_treasure_locations(self):
        height_map = defaultdict(list)
        for y, row in enumerate(self.grid):
            for x, _ in enumerate(row):
                value = self.grid[y][x]
                if value != 99:
                    height_map[value].append((x, y))
        for points in height_map.values():
            labels = rnd.choice(["treasure", "spawn", "empty"], size=len(points), p=[0.007, 0.007, 0.986])
            for coordinates, label in zip(points, labels):
                if label == "treasure":
                    self.treasure_locations.append(coordinates)
                if label == "spawn":
                    self.spawn_points.append(coordinates)
        self.spawn_points = sorted(self.spawn_points, key=lambda x: (x[0], x[1]))
        self.entrance = self.spawn_points.pop(0)
        self.exit = self.spawn_points.pop()
        self.hint_location = self.treasure_locations.pop(rnd.choice(len(self.treasure_locations)))
        
    def get_map_dict(self) -> dict:
        return { 
            "grid" : self.grid.tolist(),
            "spawn_points" : self.spawn_points,
            "treasure_locations" : self.treasure_locations,
            "hint_location" : self.hint_location,
            "map_type" : "outdoor",
            "entrance" : self.entrance,
            "exit" : self.exit,                 
        }

    
